

readonly Main@ mainProxy;       //central controller
readonly Cell@ cellArray;       //array that houses atoms
readonly Compute@ computeArray; //computational kernels
readonly CkGroupID mCastGrpID;  //multicast group handle

readonly int cellArrayDimX;         // X dimension of the Cell array
readonly int cellArrayDimY;         // Y dimension of the Cell array
readonly int cellArrayDimYArrayDimZ;// Z dimension of the Cell array
readonly int finalStepCount;        // number of steps in the simulaion
readonly int firstLdbStep;          // begin load balancing after this many steps
readonly int ldbPeriod;             // load balancing period


class vec3 {
    double x, y, z;
}

class Particle {
    double mass;
    vec3 pos, acc, vel;
}
        
mainchare Main {
    entry Main(CkArgMsg m) {
        /*
        CkPrintf("\nLENNARD JONES MOLECULAR DYNAMICS START UP ...\n");

        //set variable values to a default set
        cellArrayDimX = CELLARRAY_DIM_X;
        cellArrayDimY = CELLARRAY_DIM_Y;
        cellArrayDimZ = CELLARRAY_DIM_Z;
        finalStepCount = DEFAULT_FINALSTEPCOUNT;
        firstLdbStep = DEFAULT_FIRST_LDB;
        ldbPeriod = DEFAULT_LDB_PERIOD;

        mainProxy = thisProxy;

        //branch factor for spanning tree of multicast
        int bFactor = 4;
        //creating the multicast spanning tree
        mCastGrpID = CProxy_CkMulticastMgr::ckNew(bFactor);

        int numPes = CkNumPes();
        int currPe = -1, pe;
        int cur_arg = 1;

        CkPrintf("\nInput Parameters...\n");

        //read user parameters
        //number of celles/cells in each dimension
        if (m->argc > cur_arg) {
            cellArrayDimX=atoi(m->argv[cur_arg++]);
            cellArrayDimY=atoi(m->argv[cur_arg++]);
            cellArrayDimZ=atoi(m->argv[cur_arg++]);
            CkPrintf("Cell Array Dimension X:%d Y:%d Z:%d of size %d %d %d\n",cellArrayDimX,cellArrayDimY,cellArrayDimZ,CELL_SIZE_X,CELL_SIZE_Y,CELL_SIZE_Z);
        }

        //number of steps in simulation
        if (m->argc > cur_arg) {
            finalStepCount=atoi(m->argv[cur_arg++]);
            CkPrintf("Final Step Count:%d\n",finalStepCount);
        }

        //step after which load balancing starts
        if (m->argc > cur_arg) {
            firstLdbStep=atoi(m->argv[cur_arg++]);
            CkPrintf("First LB Step:%d\n",firstLdbStep);
        }

        //periodicity of load balancing
        if (m->argc > cur_arg) {
            ldbPeriod=atoi(m->argv[cur_arg++]);
            CkPrintf("LB Period:%d\n",ldbPeriod);
        }

        //initializing the 3D cell array
        cellArray = CProxy_Cell::ckNew();
        for (int x=0; x<cellArrayDimX; x++)
            for (int y=0; y<cellArrayDimY; y++)
                for (int z=0; z<cellArrayDimZ; z++) {
                    pe = (++currPe) % numPes;
                    cellArray(x, y, z).insert(pe);
                }
        cellArray.doneInserting();

        CkPrintf("\nCells: %d X %d X %d .... created\n", cellArrayDimX, cellArrayDimY, cellArrayDimZ);

        //initializing the 6D compute array
        computeArray = CProxy_Compute::ckNew();
        for (int x=0; x<cellArrayDimX; x++)
            for (int y=0; y<cellArrayDimY; y++)
                for (int z=0; z<cellArrayDimZ; z++)
                    cellArray(x, y, z).createComputes();

        thisProxy.run();
        delete m;
        */
    }

    sdagentry void computesCreated();
    sdagentry void sectionsCreated();
    sdagentry void energySumP(double iP, double fP);
    sdagentry void energySumK(double iK, double fK);
    sdagentry void run() {
        when computesCreated() {
            computeArray.doneInserting();
            CkPrintf("Computes: %d .... created\n", (NUM_NEIGHBORS/2+1)*cellArrayDimX*cellArrayDimY*cellArrayDimZ);
            cellArray.createSection();
        }
        when sectionsCreated() {
            CkPrintf("Multicast sections .... created\n");
            CkPrintf("Starting simulation .... \n\n");
            cellArray.run();
            computeArray.run();
        }
        when energySumP(double fP, double iP), energySumK(double fK, double iK) {
            if(abs(fP + fK - iP - iK)>ENERGY_VAR) {
                CkPrintf("Energy value has varied significantly from %E to %E\n",iP+iK,fP+fK);
                CkPrintf("\nEnergy conservation test failed for maximum allowed variation of %E units.\nSIMULATION UNSUCCESSFULL\n",ENERGY_VAR);  
            } else {
                CkPrintf("\nEnergy conservation test passed for maximum allowed variation of %E units.\nSIMULATION SUCCESSFULL \n",ENERGY_VAR);
            }
            CkExit();
        }
    }
}

/*
MulticastMsg
message ParticleDataMsg {
    vec3 part[];
};
*/

chare_array [3d] Cell {
    Array<Particle, 1> particles;
    int stepCount;
    int myNumParts;
    int inbrs;
    int stepTime;
    int updateCount;
    Array<double, 1> energy;

    // CProxySection_Compute mCastSecProxy;

    entry Cell() {
        /*
        int i;
        inbrs = NUM_NEIGHBORS;
        //load balancing to be called when AtSync is called
        usesAtSync = CmiTrue;

        myNumParts = PARTICLES_PER_CELL;
        // starting random generator
        srand48(thisIndex.x+cellArrayDimX*(thisIndex.y+thisIndex.z*cellArrayDimY));

        // Particle initialization
        for(i=0; i < myNumParts; i++) {
            particles.push_back(Particle());
            particles[i].mass = HYDROGEN_MASS;

            //give random values for position and velocity
            particles[i].pos.x = drand48() * CELL_SIZE_X + thisIndex.x * CELL_SIZE_X;
            particles[i].pos.y = drand48() * CELL_SIZE_Y + thisIndex.y * CELL_SIZE_Y;
            particles[i].pos.z = drand48() * CELL_SIZE_Z + thisIndex.z * CELL_SIZE_Z;
            particles[i].vel.x = (drand48() - 0.5) * .2 * MAX_VELOCITY;
            particles[i].vel.y = (drand48() - 0.5) * .2 * MAX_VELOCITY;
            particles[i].vel.z = (drand48() - 0.5) * .2 * MAX_VELOCITY;
        }

        stepCount = 1;
        updateCount = 0;
        stepTime = 0; 
        energy[0] = energy[1] = 0;
        */
    }

    entry void createComputes() {
        /*
        int num;  

        int x = thisIndex.x;
        int y = thisIndex.y;
        int z = thisIndex.z;
        int px1, py1, pz1, dx, dy, dz, px2, py2, pz2;

        // For Round Robin insertion
        int numPes = CkNumPes();
        int currPe = CkMyPe();

        computesList = new int*[inbrs];
        for (int i =0; i < inbrs; i++){
            computesList[i] = new int[6];
        }

        for (num=0; NUM_NEIGHBORS<inbrs; num++) {
            dx = num / (NBRS_Y * NBRS_Z)            - NBRS_X/2;
            dy = (num % (NBRS_Y * NBRS_Z)) / NBRS_Z   - NBRS_Y/2;
            dz = num % NBRS_Z                       - NBRS_Z/2;

            if (num >= inbrs/2){
                px1 = x + 2;
                px2 = x+dx+2;
                py1 = y + 2;
                py2 = y+dy+2;
                pz1 = z + 2;
                pz2 = z+dz+2;
                computeArray(px1, py1, pz1, px2, py2, pz2).insert((++currPe)%numPes);
                computesList[num][0] = px1; computesList[num][1] = py1; computesList[num][2] = pz1; 
                computesList[num][3] = px2; computesList[num][4] = py2; computesList[num][5] = pz2;
            }
            else {
                // these computes will be created by pairing celles
                px2 = WRAP_X(x+dx);
                py2 = WRAP_Y(y+dy);
                pz2 = WRAP_Z(z+dz);
                px1 = x;
                py1 = y;
                pz1 = z; 
                px1 = px2 - dx + 2;
                px2 = px2+2;
                py1 = py2 - dy + 2;
                py2 = py2+2;
                pz1 = pz2 - dz + 2;
                pz2 = pz2+2;
                computesList[num][0] = px2; computesList[num][1] = py2; computesList[num][2] = pz2; 
                computesList[num][3] = px1; computesList[num][4] = py1; computesList[num][5] = pz1;
            }
        } // end of for loop
        contribute(0,NULL,CkReduction::nop,CkCallback(CkReductionTarget(Main,computesCreated),mainProxy));
        */
    }

    entry void createSection() {
        /*
        CkVec<CkArrayIndex6D> elems;
        //create a vector list of my computes
        for (int num=0; num<inbrs; num++)
            elems.push_back(CkArrayIndex6D(computesList[num][0], computesList[num][1], computesList[num][2], computesList[num][3], computesList[num][4], computesList[num][5]));

        CkArrayID computeArrayID = computeArray.ckGetArrayID();
        //knit the computes into a section
        mCastSecProxy = CProxySection_Compute::ckNew(computeArrayID, elems.getVec(), elems.size()); 

        //delegate the communication responsibility for this section to multicast library
        CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(mCastGrpID).ckLocalBranch();
        mCastSecProxy.ckSectionDelegate(mCastGrp);
        mCastGrp->setReductionClient(mCastSecProxy, new CkCallback(CkReductionTarget(Cell,reduceForces), thisProxy(thisIndex.x, thisIndex.y, thisIndex.z)));
        contribute(0,NULL,CkReduction::nop,CkCallback(CkReductionTarget(Main,sectionsCreated),mainProxy));
        */
    }

    void sendPositions() {
        /*
        int len = particles.length();

        //create the particle and control message to be sent to computes
        ParticleDataMsg* msg = new (len) ParticleDataMsg;
        msg->x = thisIndex.x;
        msg->y = thisIndex.y;
        msg->z = thisIndex.z;
        msg->lengthAll = len;

        for (int i = 0; i < len; i++)
            msg->part[i] = particles[i].pos;

        mCastSecProxy.calculateForces(msg);
        */
    }

    void migrateParticles() {
        /*
        int i, x1, y1, z1;
        CkVec<Particle> *outgoing = new CkVec<Particle>[inbrs];

        for(i=0; i<particles.length(); i++) {
            migrateToCell(particles[i], x1, y1, z1);
            if(x1!=0 || y1!=0 || z1!=0) {
                outgoing[(x1+1)*NBRS_Y*NBRS_Z + (y1+1)*NBRS_Z + (z1+1)].push_back(wrapAround(particles[i]));
                particles.remove(i);
            }
        }
        for(int num=0; num<inbrs; num++) {
            x1 = num / (NBRS_Y * NBRS_Z)            - NBRS_X/2;
            y1 = (num % (NBRS_Y * NBRS_Z)) / NBRS_Z - NBRS_Y/2;
            z1 = num % NBRS_Z                       - NBRS_Z/2;
            cellArray(WRAP_X(thisIndex.x+x1), WRAP_Y(thisIndex.y+y1), WRAP_Z(thisIndex.z+z1)).receiveParticles(outgoing[num]);
        }
        delete [] outgoing;
        */
    }

    void migrateToCell(Particle p, int px, int py, int pz) {
        /*
        // currently this is assuming that particles are
        // migrating only to the immediate neighbors
        int x = thisIndex.x * CELL_SIZE_X + CELL_ORIGIN_X;
        int y = thisIndex.y * CELL_SIZE_Y + CELL_ORIGIN_Y;
        int z = thisIndex.z * CELL_SIZE_Z + CELL_ORIGIN_Z;
        px = py = pz = 0;

        if (p.pos.x < x) px = -1;
        else if (p.pos.x > x+CELL_SIZE_X) px = 1;

        if (p.pos.y < y) py = -1;
        else if (p.pos.y > y+CELL_SIZE_Y) py = 1;

        if (p.pos.z < z) pz = -1;
        else if (p.pos.z > z+CELL_SIZE_Z) pz = 1;
        */
    }

    void updateProperties(vec3 forces, int lengthUp) {
        /*
        int i;
        double powTen, powFteen, realTimeDelta, invMassParticle;
        powTen = pow(10.0, -10);
        powFteen = pow(10.0, -15);
        realTimeDelta = DEFAULT_DELTA * powFteen;
        for(i = 0; i < particles.length(); i++) {
            //calculate energy only in begining and end
            if(stepCount == 1) {
                energy[0] += (0.5 * particles[i].mass * dot(particles[i].vel, particles[i].vel));
            } else if(stepCount == finalStepCount) { 
                energy[1] += (0.5 * particles[i].mass * dot(particles[i].vel, particles[i].vel));
            }
            // applying kinetic equations
            invMassParticle = 1 / particles[i].mass;
            particles[i].acc = forces[i] * invMassParticle;
            particles[i].vel += particles[i].acc * realTimeDelta;

            limitVelocity(particles[i]);

            particles[i].pos += particles[i].vel * realTimeDelta;
        }
        */
    }

    double velocityCheck(double inVelocity) {
        /*
        if(fabs(inVelocity) > MAX_VELOCITY) {
            if(inVelocity < 0.0 )
                return -MAX_VELOCITY;
            else
                return MAX_VELOCITY;
        } else {
            return inVelocity;
        }
        */
    }

    void limitVelocity(Particle p) {
        /*
        p.vel.x = velocityCheck(p.vel.x);
        p.vel.y = velocityCheck(p.vel.y);
        p.vel.z = velocityCheck(p.vel.z);
        */
    }

    Particle wrapAround(Particle p) {
        /*
        if(p.pos.x < CELL_ORIGIN_X) p.pos.x += CELL_SIZE_X*cellArrayDimX;
        if(p.pos.y < CELL_ORIGIN_Y) p.pos.y += CELL_SIZE_Y*cellArrayDimY;
        if(p.pos.z < CELL_ORIGIN_Z) p.pos.z += CELL_SIZE_Z*cellArrayDimZ;
        if(p.pos.x > CELL_ORIGIN_X + CELL_SIZE_X*cellArrayDimX) p.pos.x -= CELL_SIZE_X*cellArrayDimX;
        if(p.pos.y > CELL_ORIGIN_Y + CELL_SIZE_Y*cellArrayDimY) p.pos.y -= CELL_SIZE_Y*cellArrayDimY;
        if(p.pos.z > CELL_ORIGIN_Z + CELL_SIZE_Z*cellArrayDimZ) p.pos.z -= CELL_SIZE_Z*cellArrayDimZ;
        return p;
        */
    }

    sdagentry void receiveParticles(Array<Particle, 1> updates);
    sdagentry void ResumeFromSync();
    sdagentry void reduceForces(Array<vec3, 1> forces);
    sdagentry void run() {
        if(thisIndex.x==0 && thisIndex.y==0 && thisIndex.z==0) {
            stepTime = CkWallTimer();
        }

        for(int stepCount = 1; stepCount <= finalStepCount; stepCount++) {
            //send current atom positions to my computes 
            sendPositions();

            //update properties of atoms using new force values 
            when reduceForces(Array<vec3, 1> forces) updateProperties(forces);

            if ((stepCount %  MIGRATE_STEPCOUNT) == 0) {
                //send atoms that have moved beyond my cell to neighbors
                migrateParticles();

                //receive particles from my neighbors
                for(int updateCount = 0; updateCount < inbrs; updateCount++) {
                    when receiveParticles(Array<Particle, 1> updates) {
                        for(int i=0; i < updates.length(); i++) {
                            particles.push_back(updates[i]);    //add particles that have moved from neighboring celles to my cell
                        }
                    }
                }
            }
            if (thisIndex.x==0 && thisIndex.y==0 && thisIndex.z==0 && stepCount%20==0) {
                CkPrintf("Step %d Benchmark Time %lf ms/step\n", 
                        stepCount, ((CkWallTimer() - stepTime)/20)*1000);
                stepTime = CkWallTimer();
            }
            //periodically call load balancer
            if (stepCount >= firstLdbStep && (stepCount - firstLdbStep) % ldbPeriod == 0) {
                AtSync();
                when ResumeFromSync() stepTime = CkWallTimer();
            }
        }
        //everything done, reduction on kinetic energy
        /*
        contribute(2*sizeof(double),
                energy,
                CkReduction::sum_double,
                CkCallback(CkReductionTarget(Main,energySumK),
                mainProxy));
        */
    } 
}

chare_array [6d] Compute {
    entry Compute() {
        cellCount = 0;
        energy[0] = energy[1] = 0;
    }

   // void interact(ParticleDataMsg msg) {
        /*
        double energyP = 0;

        //self interaction check
        if (thisIndex.x1 ==thisIndex.x2 && thisIndex.y1 ==thisIndex.y2 && thisIndex.z1 ==thisIndex.z2) {
            CkGetSectionInfo(mcast1,msg);
            energyP = calcInternalForces(msg, &mcast1, stepCount);
        } else {
            //check if this is the first message or second
            if (cellCount == 0) {
                bufferedMsg = msg;
                cellCount++;
                return;
            }
            // Both particle sets have been received, so compute interaction
            cellCount = 0;
            ParticleDataMsg *msgA = msg, *msgB = bufferedMsg;
            CkSectionInfo *handleA = &mcast1, *handleB = &mcast2;
            if (bufferedMsg->x*cellArrayDimY*cellArrayDimZ + bufferedMsg->y*cellArrayDimZ + bufferedMsg->z < msg->x*cellArrayDimY*cellArrayDimZ + msg->y*cellArrayDimZ + msg->z){ 
                swap(handleA, handleB);
            }
            if (bufferedMsg->lengthAll <= msg->lengthAll) {
                swap(msgA, msgB);
                swap(handleA, handleB);
            }

            energyP = calcPairForces(msgA, msgB, handleA, handleB, stepCount);
            bufferedMsg = NULL;
        }
        //energy assignment only in begining and end
        if(stepCount == 1) {
            energy[0] = energyP;
        } else if(stepCount == finalStepCount) {
            energy[1] = energyP;
        }
        */
    //}

    sdagentry void ResumeFromSync();
    //sdagentry void calculateForces(ParticleDataMsg msg);
    sdagentry void calculateForces_dummy();
    sdagentry void run() {
        for (stepCount = 1; stepCount <= finalStepCount; stepCount++) {
            //self interaction check
            if (thisIndex.x1==thisIndex.x2 && thisIndex.y1==thisIndex.y2 && thisIndex.z1==thisIndex.z2) {
                //when calculateForces(ParticleDataMsg *msg) interact(msg);
                when calculateForces_dummy() { }
            } else {
                //receive positions from two cells
                //when calculateForces(ParticleDataMsg *msg) interact(msg);
                //when calculateForces(ParticleDataMsg *msg) interact(msg);
                when calculateForces_dummy() { }
                when calculateForces_dummy() { }
            }
            //periodically call load balancer
            if (stepCount >= firstLdbStep && (stepCount - firstLdbStep) % ldbPeriod == 0) {
                AtSync();
                when ResumeFromSync() { }
            }
        }
        //everything done, reduction on potential energy
        /*
        contribute(2*sizeof(double),
            energy,
            CkReduction::sum_double,
            CkCallback(CkReductionTarget(Main,energySumP),
            mainProxy));
        */
    }
}

/* defs.h */
/*
#ifndef __DEFS__
#define __DEFS__

#include "pup.h"

#define HYDROGEN_MASS         (1.67 * pow( 10.0,-24))
#define VDW_A                        (1.60694452 * pow(10.0, -134))
#define VDW_B            (1.031093844 * pow(10.0, -77))

#define ENERGY_VAR        (1.0 * pow(10.0,-5))
#powdefine PARTICLES_PER_CELL   300

#define DEFAULT_DELTA         1// interact femtoseconds

#define DEFAULT_FIRST_LDB     20
#define DEFAULT_LDB_PERIOD    20
#define DEFAULT_FT_PERIOD     100000

#define KAWAY_X               1
#define KAWAY_Y               1
#define KAWAY_Z               1
#define NBRS_X              (2*KAWAY_X+1)
#define NBRS_Y            (2*KAWAY_YWAY_Y+1)
#define NBRS_Z            (2*KAWAY_Z+1)
#define NUM_NEIGHBORS        (NBRS_X * NBRS_Y * NBRS_Z)

#define CELLARRAY_DIM_X      3
#definedefine CELLARRAY_DIM_Y      3
#define CELLARRAY_DIM_Z      3
#define         PTP_CUT_OFF        12 // cut off for atom to atom interactions
#definedefinee CELL_MARGIN        4  // constant diff between cutoff and cell size#define CELL_SIZE_X        (PTP_CUT_OFF + CELL_MARGIN)/KAWAY_X
#definedefineene CELL_SIZE_Y        (PTP_CUT_OFF + CELL_MARGIN)/KAWAY_Y
#define CELL_SIZE_YL_SIZE_Z        (PTP_CUT_OFF + CELL_MARGIN)/KAWAY_Z
#define CELL_ORIGIN_YIN_X      0
#define CELL_ORIGIN_Y      0
#define CELL_ORIGIN_Z                              0

#define MIGRATE_STEPCOUNT    20
#define DEFAULT_FINALSTEPCOUNT1001
#define MAX_VELOCITY      30.0

#define WRAP_X(a)(((a)+cellArrayyDimX)%cellArrayDimX)
#define WRAP_Y(a)(((a)+cellArrayDimY)%cellArrayDimXDimY)
#define WRAP_Z(a)(((a)+cellArrayDimZ)%cellArrayDimZ)

struct velc3 {
  double x, y, z;

  vec3(double d = 0.0) : x(d), y(d), z(d) { }
  vec3(double x_, double y_, double z_) : x(x_), y(y_), z(z_) { }

  inline vec3& operator += (const vec3 &rhs) {
    x += rhs.x; y += rhs.y; z += rhs.z;
    return *this;
  }
  inline vec3& operator -= (const vec3 &rhs) {
    return *this += (rhs * -1.0);
  }
  inline vec3 operator* (const double d) const {
    return vec3(d*x, d*y, d*z);
  }
  inline vec3 operator- (const vec3& rhs) const {
    return vec3(x - rhs.x, y - rhs.y, z - rhs.z);
  }
};
inline double dot(const vec3& a, const vec3& b) {
  return a.x*b.x + a.y*b.y + a.z*b.z;
}
PUPbytes(vec3)

//class for keeping track of the properties for a particle
struct Particle {
  double mass;
  //   Position, acceleration, velocity
  vec3 pos,acc,vel;

  // Function for pupping properties
  void pup(PUP::er &p) {
    p | mass;
    p | pos;
    p | acc;
    p | vel;
  }
};
#endif
*/

/* physics.h */
/*
#define BLOCK_SIZE512

//function to calculate forces among 2 limitVelocitysts of atoms
inline double calcPairForces(ParticleDataMsg* first, ParticleDataMsg* second, CkSectionInfo* mcast1, CkSectionInfo* mcast2, int stepCount) {
  int i, j, jpart, ptpCutOffSqd, diff;
  int firstLen = first->lengthAll;
  int secondLen = second->lengthAll;
  double powTwenty, powTen, r, rsqd, f, fr;
  vec3 separation, force;
  double rSix, rTwelve;
  double energy = 0;
  int doEnergy = 0;
  if(stepCount == 1 || stepCount == finalStepCount)
    doEnergy = 1;

  vec3 *firstmsg = new vec3[firstLen];
  vec3 *secondmsg = new vec3[secondLen];
  //check for wrap around and adjust locations accordingly
  if (abs(first->x - second->x) > 1){
    diff = CELL_SIZE_X * cellArrayDimX;
    if (second->x < first->x)
      diff = -1 * diff; 
    for (i = 0; i < firstLen; i++)
      first->part[i].x += diff;
  }
  if (abs(first->y - second->y) > 1){
    diff = CELL_SIZE_Y * cellArrayDimY;
    if (second->y < first->y)
      diff = -1 * diff; 
    for (i = 0; i < firstLen; i++)
      first->part[i].y += diff;
  }
  if (abs(first->z - second->z) > 1){
    diff = CELL_SIZE_Z * cellArrayDimZ;
    if (second->z < first->z)
      diff = -1 * diff; 
    for (i = 0; i < firstLen; i++)
      first->part[i].z += diff;
  } 
  ptpCutOffSqd = PTP_CUT_OFF * PTP_CUT_OFF;
  powTen = pow(10.0, -10);
  powTwenty = pow(10.0, -20);

  int i1, j1;
  for(i1 = 0; i1 < firstLen; i1=i1+BLOCK_SIZE)
    for(j1 = 0; j1 < secondLen; j1=j1+BLOCK_SIZE)
      for(i = i1; i < i1+BLOCK_SIZE && i < firstLen; i++) {
        for(jpart = j1; jpart < j1+BLOCK_SIZE && jpart < secondLen; jpart++) {
          separation = first->part[i] - second->part[jpart];
          rsqd = dot(separation, separation);
          if (rsqd >= 0.001 && rsqd < ptpCutOffSqd) {
            rsqd = rsqd * powTwenty;
            r = sqrt(rsqd);
            rSix = ((double)rsqd) * rsqd * rsqd;
            rTwelve = rSix * rSix;
            f = (double)(VDW_A / rTwelve - VDW_B / rSix);
            if(doEnergy)
              energy += (double)( VDW_A / (12*rTwelve) - VDW_B / (6*rSix));
            fr = f /r;
            force = separation * (fr * powTen);
            firstmsg[i] += force;
            secondmsg[jpart] -= force;
          }
        }
      }

  CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(mCastGrpID).ckLocalBranch();
  CkGetSectionInfo(*mcast1, first);
  mCastGrp->contribute(sizeof(vec3)*firstLen, firstmsg, CkReduction::sum_double, *mcast1);
  CkGetSectionInfo(*mcast2, second);
  mCastGrp->contribute(sizeof(vec3)*secondLen, secondmsg, CkReduction::sum_double, *mcast2);

  delete [] firstmsg;
  delete [] secondmsg;
  delete first;
  delete second;
  return energy;
}

//function to calculate forces among atoms in a single list
inline double calcInternalForces(ParticleDataMsg* first, CkSectionInfo *mcast1, int stepCount) {
  int i, j, ptpCutOffSqd;
  int firstLen = first->lengthAll;
  double powTwenty, powTen, firstx, firsty, firstz, rx, ry, rz, r, rsqd, fx, fy, fz, f, fr;
  vec3 firstpos, separation, force;
  double rSix, rTwelve;
  double energy = 0;
  int doEnergy = 0;
  if(stepCount == 1 || stepCount == finalStepCount)
    doEnergy = 1;
  vec3 *firstmsg = new vec3[firstLen];

  ptpCutOffSqd = PTP_CUT_OFF * PTP_CUT_OFF;
  powTen = pow(10.0, -10);
  powTwenty = pow(10.0, -20);
  for(i = 0; i < firstLen; i++){
    firstpos = first->part[i];
    for(j = i+1; j < firstLen; j++) {
      // computing base values
      separation = firstpos - first->part[j];
      rsqd = dot(separation, separation);
      if(rsqd >= 0.001 && rsqd < ptpCutOffSqd){
        rsqd = rsqd * powTwenty;
        r = sqrt(rsqd);
        rSix = ((double)rsqd) * rsqd * rsqd;
        rTwelve = rSix * rSix;
        f = (double)(VDW_A / rTwelve - VDW_B / rSix);
        if(doEnergy)
          energy += (double)( VDW_A / (12*rTwelve) - VDW_B / (6*rSix));

        fr = f /r;
        force = separation * (fr * powTen);
        firstmsg[j] += force;
        firstmsg[i] -= force;
      }
    }
  }
  CkMulticastMgr *mCastGrp = CProxy_CkMulticastMgr(mCastGrpID).ckLocalBranch();
  mCastGrp->contribute(sizeof(vec3)*firstLen, firstmsg, CkReduction::sum_double, *mcast1);
  delete [] firstmsg;
  delete first;
  return energy;
}
#endif
*/
