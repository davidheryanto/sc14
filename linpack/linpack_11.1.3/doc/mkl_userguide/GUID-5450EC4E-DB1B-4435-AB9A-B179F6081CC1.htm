<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0014)about:internet -->
<html xmlns:MSHelp="http://www.microsoft.com/MSHelp/" lang="en-us" xml:lang="en-us"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="DC.Type" content="topic">
<meta name="DC.Title" content="Options to Reduce Search Time">
<meta name="DC.Relation" scheme="URI" content="GUID-10DFCB17-3953-47C6-9971-8C455A925BFE.htm">
<meta name="DC.Relation" scheme="URI" content="GUID-BBF32C0A-50BF-4BFA-884D-DBAD37721E32.htm#GUID-BBF32C0A-50BF-4BFA-884D-DBAD37721E32">
<meta name="DC.Relation" scheme="URI" content="http://www.intel.com/software/products/softwaredocs_feedback">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="GUID-5450EC4E-DB1B-4435-AB9A-B179F6081CC1">
<meta name="DC.Language" content="en-US">
<link rel="stylesheet" type="text/css" href="intel_css_styles.css">
<title>Options to Reduce Search Time</title>
<xml>
<MSHelp:Attr Name="DocSet" Value="Intel"></MSHelp:Attr>
<MSHelp:Attr Name="Locale" Value="kbEnglish"></MSHelp:Attr>
<MSHelp:Attr Name="TopicType" Value="kbReference"></MSHelp:Attr>
</xml>
</head>
<body id="GUID-5450EC4E-DB1B-4435-AB9A-B179F6081CC1">
 <!-- ==============(Start:NavScript)================= -->
 <script src="NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(0);</script>
 <!-- ==============(End:NavScript)================= -->
<p id="header_text" style="margin-bottom : 20pt"><em>Intel&reg; Math Kernel Library 11.1 Update 3 User's Guide</em></p>


 
  <h1 class="topictitle1">Options to Reduce Search Time</h1>
 
   
  <div id="GUID-A9F65D3A-168A-413F-95D8-68A40E1BFD4A"> 
    <p id="GUID-2C1818EE-3D8B-4FEA-B1D5-7E72568D9EEC">Running large problems to completion on large numbers of nodes can take many hours. The search space for the Intel Optimized LINPACK Benchmark is also large: you can vary several parameters to improve performance, such as problem size, block size, grid layout, lookahead steps, factorization methods, and so on. You might not want to run a large problem to completion only to discover that it ran 0.01% slower than your previous best problem. 
    </p>
 
    <p id="GUID-2822FCCA-45D0-427B-9402-B4D8764A800A">Use the following options to reduce the search time: 
    </p>
 
    <ul id="GUID-94D38B7E-3B73-4ADB-A400-5306773EF3AC"> 
      <li> 
        <p id="GUID-072717A7-E16C-4E10-B639-A23449E6673C"> 
          <samp class="codeph" id="GUID-F7AB22BA-8105-4A16-A558-86A556A9D2DF">-DASYOUGO</samp> 
        </p>
 
      </li>
 
      <li> 
        <p id="GUID-2D384248-6DAE-483D-937E-75F702D321C0"> 
          <samp class="codeph" id="GUID-0E97E271-2D33-4AF2-9139-704E8302386C">-DENDEARLY</samp>, 
        </p>
 
      </li>
 
      <li> 
        <p id="GUID-BEE3A6D0-BEEB-485C-966F-C2BA03643600"> 
          <samp class="codeph" id="GUID-8F1D5D9C-ED09-4932-8F52-F9E1332C36AA">-DASYOUGO2</samp>, 
        </p>
 
        <p id="GUID-EFCB4D73-A97B-476C-9D49-949F130F8749">Use 
          <samp class="codeph" id="GUID-F278C115-370B-44B2-B07A-7C4684BCCF92">-DASYOUGO2</samp> cautiously because it has a marginal performance impact. To see 
          <samp class="codeph" id="GUID-10C9A9FF-C472-4EFF-B4C6-2F45CE20C4AD">DGEMM</samp> internal performance, compile with 
          <samp class="codeph" id="GUID-05A705FE-48EA-4BA3-8478-E78DE992D873">-DASYOUGO2</samp> and 
          <samp class="codeph" id="GUID-D6C5A763-7FF8-4D86-87A8-BEC4C3B57E9C">-DASYOUGO2_DISPLAY</samp>. These options provide useful 
          <samp class="codeph" id="GUID-6C7AF102-36EB-4706-98F9-3AF60C4F0E56">DGEMM</samp> performance information at the cost of around 0.2% performance loss. 
        </p>
 
      </li>
 
    </ul>
 
    <p id="GUID-A785E663-EFC1-46C4-9281-0CB46B2CEE7D">If you want to use the original HPL, simply omit these options and recompile from scratch. To do this, try 
      <samp class="codeph" id="GUID-A5A98FE8-03B7-408C-B5A9-4E0AA9B8FCD1">"make arch=<var>&lt;arch&gt;</var> clean_arch_all".</samp> 
    </p>
 
    <div class="section" id="GUID-F8FB9AB4-0E91-48DE-9D99-9939A7F66874"><h2 class="sectiontitle">-DASYOUGO</h2> 
       
      <p id="GUID-32B45298-DD6C-45A8-9AFB-EB1D10DD5165"> 
        <samp class="codeph" id="GUID-12B94CD8-F68E-4331-B9A0-585F287277D4">-DASYOUGO</samp> gives performance data as the run proceeds. The performance always starts off higher and then drops because the LU decomposition slows down as it goes. So the 
        <samp class="codeph" id="GUID-3BAE4056-BC4A-42F2-B4CB-0BE9B1B4C6D4">ASYOUGO</samp> performance estimate is usually an overestimate, but it gets more accurate as the problem proceeds. The greater the lookahead step, the less accurate the first number may be. 
        <samp class="codeph" id="GUID-69C369EE-D582-4D47-979D-6AD426DADAA2">ASYOUGO</samp> tries to estimate where execution is in the LU decomposition that Intel Optimized LINPACK Benchmark performs, and this is always an overestimate as compared to 
        <samp class="codeph" id="GUID-869FC493-079C-4094-8A98-90AA25AFDBCE">ASYOUGO2</samp>, which measures actually achieved 
        <samp class="codeph" id="GUID-392BC2A0-0EC0-42EE-987D-B0CD5229D340">DGEMM</samp> performance. Note that the 
        <samp class="codeph" id="GUID-AB94E9D4-E319-4A65-8704-B018C2478FF3">ASYOUGO</samp> output is a subset of the information that 
        <samp class="codeph" id="GUID-1FABA300-BAF0-49D9-9942-FD76C612ACED">ASYOUGO2</samp> provides. Refer to the description of the 
        <samp class="codeph" id="GUID-26E6366A-7ABF-49AD-92D5-5A7FF03524A0"><a href="GUID-5450EC4E-DB1B-4435-AB9A-B179F6081CC1.htm">Options to Reduce Search Time</a></samp> option below for the details of the output. 
      </p>
 
    </div>
 
    <div class="section" id="GUID-57C90A9D-2F5A-4917-BB9F-85A25CD90F34"><h2 class="sectiontitle">-DENDEARLY</h2> 
       
      <p id="GUID-5EB7C6A3-F6FA-43A2-996F-64EFCC35EDA7"> 
        <samp class="codeph" id="GUID-558778DF-0965-41EE-824B-4740ED96C8B5">-DENDEARLY</samp> terminates the problem after a few steps, so that you can set up 10 or 20 HPL runs without monitoring them, see how they all do, and then only run the fastest ones to completion. 
        <samp class="codeph" id="GUID-510B57FA-5721-4391-BA90-2A5BE1249E5F">-DENDEARLY</samp> assumes 
        <samp class="codeph" id="GUID-0BBB6C8E-B4F1-4AD8-806B-DB90CC0D25A4">-DASYOUGO</samp>. You can define both, but it is not necessary. To avoid the residual check for a problem that terminates early, set the 
        <span class="keyword">threshold</span> parameter in 
        <span class="filepath" id="GUID-48863D78-1131-4829-8C19-5A0F66F14047">HPL.dat</span> to a negative number when testing 
        <samp class="codeph" id="GUID-2F60A16C-9E8E-4572-96ED-2E15B6C81107">ENDEARLY</samp>. It also sometimes gives more information to compile with 
        <samp class="codeph" id="GUID-E112D5CD-2D6A-4E10-A70B-AAD974F720ED">-DASYOUGO2</samp> when using 
        <samp class="codeph" id="GUID-8ED53889-8E20-42AE-9C7D-53BD2C9A8440">-DENDEARLY</samp>. 
      </p>
 
      <p id="GUID-7EA6CC0F-3AF3-42E7-BF44-90B45257AFBA">Usage notes on 
        <samp class="codeph" id="GUID-120160C2-F57F-4ABC-BD16-6C4F62703403">-DENDEARLY</samp> follow: 
      </p>
 
      <ul id="GUID-B116E95D-D45D-4878-BD1F-41BA7DCC26E0"> 
        <li> 
          <p id="GUID-32A14B99-B280-4786-866F-8CDC2DEC171A"> 
            <samp class="codeph" id="GUID-7CB30F1F-13E7-476A-9152-A133920A4772">-DENDEARLY</samp> stops the problem after a few iterations of 
            <samp class="codeph" id="GUID-C79D75D3-C67C-4EBD-BC43-E6D361B5A762">DGEMM</samp> on the block size (the bigger the blocksize, the further it gets). It prints only five or six updates, whereas 
            <samp class="codeph" id="GUID-FE7A6603-102B-448E-A81B-1AF1A95A7620">-DASYOUGO</samp> prints about 46 or so output elements before the problem completes. 
          </p>
 
        </li>
 
        <li> 
          <p id="GUID-72E67E21-2BD6-4696-9036-C7522229B737">Performance for 
            <samp class="codeph" id="GUID-10198787-F607-4FFF-BCCB-57BBD258F48C">-DASYOUGO</samp> and 
            <samp class="codeph" id="GUID-80692186-D74B-4150-9915-21EB9F99E9AE">-DENDEARLY</samp> always starts off at one speed, slowly increases, and then slows down toward the end (reflecting the progress of the LU decomposition). 
            <samp class="codeph" id="GUID-4089D909-819F-431C-AC24-81FE23C7107C">-DENDEARLY</samp> is likely to terminate before it starts to slow down. 
          </p>
 
        </li>
 
        <li> 
          <p id="GUID-25B55A5B-EFA5-4952-8CCB-61F689190237"> 
            <samp class="codeph" id="GUID-774D94BB-66C4-4929-8C9D-A73AC9C05901">-DENDEARLY</samp> terminates the problem early with an HPL Error exit. It means that you need to ignore the missing residual results, which are wrong because the problem never completed. However, you can get an idea what the initial performance was, and if it is acceptable, run the problem to completion without 
            <samp class="codeph" id="GUID-6147CF4D-EB52-4545-B35E-3A6576501514">-DENDEARLY</samp>. To avoid the error check, you can set the 
            <span class="keyword">threshold</span> parameter in 
            <span class="filepath" id="GUID-55180DD1-381F-443B-97E3-A494B7FBACA4">HPL.dat</span> to a negative number. 
          </p>
 
        </li>
 
        <li> 
          <p id="GUID-4B1B234B-4C8B-4B21-A5CC-F8ACAF7F7B93">Though 
            <samp class="codeph" id="GUID-9E103B24-295C-46DC-8E84-504163F1E1AC">-DENDEARLY</samp> terminates early, HPL treats the problem as completed and computes GFLOP rating as though the problem ran to completion. Ignore this erroneously high rating. 
          </p>
 
        </li>
 
        <li> 
          <p id="GUID-E78B4A41-C17D-4C22-B016-6707D838F8E3">The bigger the problem, the more accurately the last update that 
            <samp class="codeph" id="GUID-0CF1AF9E-1C88-423F-B8E8-402E7E64C132">-DENDEARLY</samp> returns is close to what happens when the problem runs to completion. 
            <samp class="codeph" id="GUID-DC4D25DA-9C16-4BCC-8DE2-CEFBB6C97DB1">-DENDEARLY</samp> is a poor approximation for small problems. It is for this reason that you should use 
            <samp class="codeph" id="GUID-A3BE5660-F619-4584-8105-6EB2BE63CC5D">ENDEARLY</samp> in conjunction with 
            <samp class="codeph" id="GUID-0079FC4D-79CE-4642-9830-99D05EFD1F40">ASYOUGO2</samp>, because 
            <samp class="codeph" id="GUID-87F2FEF0-E050-41DC-A709-4622EF4C9424">ASYOUGO2</samp> reports actual 
            <samp class="codeph" id="GUID-5A935BFE-6A32-4C34-A0A2-BC04CD26D715">DGEMM</samp> performance, which can be a closer approximation to problems just starting. 
          </p>
 
        </li>
 
      </ul>
 
      </div>
 
    <div class="section" id="XREF__DASYOUGO2"><a name="XREF__DASYOUGO2"><!-- --></a><h2 class="sectiontitle">-DASYOUGO2</h2> 
       
      <p id="GUID-7621D1FE-AEDA-4C55-B4B6-A550368A7CEA"> 
        <samp class="codeph" id="GUID-A9712193-A309-433C-B167-F23054BD7E35">-DASYOUGO2</samp> gives detailed single-node 
        <samp class="codeph" id="GUID-B8418757-4CC3-4A13-8CBE-883F63D8D042">DGEMM</samp> performance information. It captures all 
        <samp class="codeph" id="GUID-9A7532A8-132D-4912-9524-DDD622D505E6">DGEMM</samp> calls (if you use Fortran BLAS) and records their data. Because of this, the routine has a marginal performance overhead. Unlike 
        <samp class="codeph" id="GUID-791E80D7-32A9-49C6-B672-D619B80D8ECD">-DASYOUGO</samp>, which does not impact performance, 
        <samp class="codeph" id="GUID-8B97B7C2-2E35-4044-9E7E-41A5A6FE286E">-DASYOUGO2</samp> interrupts every 
        <samp class="codeph" id="GUID-975C5388-0C9A-4734-ADDF-20975B598796">DGEMM</samp> call to monitor its performance. You should be aware of this overhead, although for big problems, it is less than 
        0.2%. 
      </p>
 
      <p id="GUID-638C4C4E-8CEB-4FE8-BF68-8CA21AB2823A">A sample 
        <samp class="codeph" id="GUID-9B96AAB9-7DE4-4BC1-AFE1-7E2EA5BE4470">ASYOUGO2</samp> output appears as follows: 
      </p>
 
      <p id="GUID-F21FC8C5-8175-4211-ABE2-2E04922E74E9"> 
        <samp class="codeph" id="GUID-1C029D55-0737-49B2-B45E-385550D239F5">Col=001280 Fract=0.050 Mflops=42454.99 (DT=9.5 DF=34.1 DMF=38322.78)</samp>. 
      </p>
 
      <div class="Note"><h3 class="NoteTipHead">Note</h3> 
        <p>The values of 
          <samp class="codeph">Col</samp>, 
          <samp class="codeph">Fract</samp>, and 
          <samp class="codeph">Mflops</samp> are also produced for 
          <samp class="codeph">ASYOUGO</samp> and 
          <samp class="codeph">ENDEARLY</samp>. 
        </p>
 
      </div> 
      <p id="GUID-92DE4761-333A-4F66-AE15-D54530DE3AB4">In this example, the problem size is 16000 and a block size is 128. After processing 10 blocks, or 1280 columns (<samp class="codeph">Col</samp>), an output was sent to the screen. Here, the fraction of columns completed (<samp class="codeph">Fract</samp>) is 1280/16000=0.08. Only up to 111 outputs are printed, at various places through the matrix decomposition: 
        <samp class="codeph" id="GUID-AF1D944B-19CF-4B5B-87AB-999CF394B7DA"><br> 0.005 0.010 0.015 0.020 0.025 0.030 0.035 0.040 0.045 0.050 0.055 0.060 0.065 0.070 0.075 0.080 0.085 0.090 0.095 0.100 0.105 0.110 0.115 0.120 0.125 0.130 0.135 0.140 0.145 0.150 0.155 0.160 0.165 0.170 0.175 0.180 0.185 0.190 0.195 0.200 0.205 0.210 0.215 0.220 0.225 0.230 0.235 0.240 0.245 0.250 0.255 0.260 0.265 0.270 0.275 0.280 0.285 0.290 0.295 0.300 0.305 0.310 0.315 0.320 0.325 0.330 0.335 0.340 0.345 0.350 0.355 0.360 0.365 0.370 0.375 0.380 0.385 0.390 0.395 0.400 0.405 0.410 0.415 0.420 0.425 0.430 0.435 0.440 0.445 0.450 0.455 0.460 0.465 0.470 0.475 0.480 0.485 0.490 0.495 0.515 0.535 0.555 0.575 0.595 0.615 0.635 0.655 0.675 0.695 0.795 0.895.</samp> 
      </p>
 
      <p id="GUID-B344EE47-89FD-4477-AF6B-630B79B36593">However, this problem size is so small and the block size so big by comparison that as soon as it prints the value for 0.045, it was already through 0.08 fraction of the columns. On a really big problem, the fractional number is more accurate. 
      </p>
 
      <p><samp class="codeph">-DASYOUGO2</samp> never prints more than the 112 numbers above. So, smaller problems have fewer than 112 updates, and the biggest problems have precisely 112 updates. 
      </p>
 
      <p id="GUID-E5F7559F-4644-45F7-928B-5105CB0B08DA"><samp class="codeph" id="GUID-AFBEE5E6-85FA-4675-BE3A-EDD75B90986E">Mflops</samp> is an estimate based on the number of columns of the LU decomposition being completed. However, with lookahead steps, sometimes that work is not actually completed when the output is made. Nevertheless, this is a good estimate for comparing identical runs. 
      </p>
 
      <p>The three parenthesized numbers are 
        <samp class="codeph">ASYOUGO2</samp> add-ins that impact performance. 
        <samp class="codeph" id="GUID-0D20E3AD-94E7-4D67-9248-74FC116016CC">DT</samp> is the total time that processor 0 has spent in 
        <samp class="codeph" id="GUID-BBD3C47D-B64C-4FE3-9C21-3C7B708948D9">DGEMM</samp>. 
        <samp class="codeph" id="GUID-9D462DDC-C94E-4390-A30A-CA1486B9B1E5">DF</samp> is the number of billion operations that have been performed in 
        <samp class="codeph" id="GUID-89C23B39-ADC4-4EB3-9971-0726A3D2CDBB">DGEMM</samp> by one processor. Therefore, the performance of processor 0 (in GFLOPs) in 
        <samp class="codeph">DGEMM</samp> is always 
        <samp class="codeph">DF/DT</samp>. Using the number of 
        <samp class="codeph">DGEMM</samp> FLOPs as a basis instead of the number of LU FLOPs, you get a lower bound on performance of the run by looking at 
        <samp class="codeph">DMF</samp>, which can be compared to 
        <samp class="codeph">Mflops</samp> above. 
      </p>
 
      <p id="GUID-730A58F1-2CEA-4803-A933-ED2BC5D892B0">Note that when using the performance monitoring tools described in this section to compare different 
        <span class="filepath" id="GUID-786A5F49-F538-4F7D-A442-05AC8B47720B">HPL.dat</span> input data sets, you should be aware that the pattern of performance drop-off that LU experiences is sensitive to sizes of input data. For instance, when you try very small problems, the performance drop-off from the initial values to end values is very rapid. The larger the problem, the less the drop-off, and it is probably safe to use the first few performance values to estimate the difference between a problem size 700000 and 701000, for instance. Another factor that influences the performance drop-off is the relationship of the grid dimensions (<var>P</var> and 
        <var>Q</var>). For big problems, the performance tends to fall off less from the first few steps when 
        <var>P</var> and 
        <var>Q</var> are roughly equal. You can make use of a large number of parameters, such as broadcast types, and change them so that the final performance is determined very closely by the first few steps. 
      </p>
 
      <p id="GUID-0D6B50CF-9B4E-4ED1-A464-60523705F87A">Use of these tools can increase the amount of data you can test. 
      </p>
 
    </div>
 
  </div>
 
  
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong>&nbsp;<a href="GUID-10DFCB17-3953-47C6-9971-8C455A925BFE.htm">Intel&reg; Optimized MP LINPACK Benchmark for Clusters</a></div>
</div>
<div class="See Also"><h2>See Also</h2>
<div class="linklist">
<div><a href="GUID-BBF32C0A-50BF-4BFA-884D-DBAD37721E32.htm#GUID-BBF32C0A-50BF-4BFA-884D-DBAD37721E32">Optimizing the Result on a Cluster</a></div></div><br clear="all">
<div class="docfeedback">
<div><a href="http://www.intel.com/software/products/softwaredocs_feedback" target="_blank">Submit feedback on this help topic 
		  </a></div></div></div> 

</body>
</html>
